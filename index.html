<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Classical Tibetan Quote Detection + Auto/Allo</title>
    <style>
        body {
            font-family: monospace;
            margin: 1rem;
        }

        h1 {
            margin-top: 0;
        }

        textarea {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            font-family: monospace;
        }

        button {
            margin-top: 0.5rem;
            padding: 0.4rem 0.8rem;
            font-family: inherit;
            cursor: pointer;
        }

        .heatmap {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 1em;
        }

        .heatbox {
            width: 10px;
            height: 36px;              /* a bit taller for 3 bands */
            margin: 1px;
            border: 1px solid #ccc;
            display: flex;
            flex-direction: column;    /* vertical bands */
            overflow: hidden;
        }

        .heatband {
            flex: 1 1 auto;
        }

        .opener {
            background-color: #d0f0fd;
        }

        .inquote {
            background-color: #fef7cb;
        }

        .closer {
            background-color: #ffd0d0;
        }

        .none {
            background-color: white;
        }

        .meta-unselectable {
            user-select: none;
            -webkit-user-select: none;  /* Safari */
            -moz-user-select: none;     /* Firefox */
            -ms-user-select: none;      /* old Edge/IE */
        }


        span.opener,
        span.inquote,
        span.closer {
            padding: 0 2px;
            border-radius: 3px;
        }

        .clause-line {
            margin-bottom: 0.1rem;
        }

        /* Text finder styles */
        .text-finder {
            border: 1px solid #ccc;
            padding: 0.5rem;
            margin-bottom: 1rem;
        }

        .text-finder input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            font-family: monospace;
            padding: 0.25rem;
        }

        .text-finder-results {
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid #eee;
            padding-top: 0.5rem;
        }

        .text-finder-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px dashed #eee;
            font-size: 0.9rem;
        }

        .text-finder-item span {
            margin-right: 0.5rem;
        }

        .text-finder-meta {
            color: #555;
            font-size: 0.8rem;
        }

        /* Allo/auto badge left of line numbers */
        .allo-auto-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 3.0em;
            min-width: 3.0em;
            padding: 1px 4px;
            margin-right: 0.4rem;
            border-radius: 3px;
            font-size: 0.8rem;
            color: #ffffff;
            box-sizing: border-box;
        }

        .verse-line {
            font-weight: bold;
        }
    </style>
</head>

<body>
    <h1>Classical Tibetan Quote Detection</h1>
    <p id="modelStatus" style="font-size:0.9rem; color:#555;">
        Model: loading auto/allo classifier...
    </p>

    <!-- TEXT FINDER UI -->
    <div class="text-finder">
        <strong>Find a text from Derge / Nyingma / ACIP Sungbum</strong>
        <p style="margin-top:0.25rem;">
            Start typing part of the text name or filename (e.g. <code>D406</code>), then click a match to load it into
            the detector.
        </p>
        <input type="text" id="textSearchInput" placeholder="Type part of a text name or filename...">
        <div id="textSearchStatus" style="margin-top:0.25rem; font-size:0.8rem; color:#555;">
            Loading corpus indexes...
        </div>
        <div id="textSearchResults" class="text-finder-results"></div>
    </div>

    <p>
        Paste your Tibetan text below (clauses separated by <code>/</code> or <code>//</code>),
        then click <strong>Detect quotes</strong>.
    </p>

    <textarea id="inputText" rows="10" placeholder="Paste Tibetan text here..."></textarea>
    <br>
    <input type="checkbox" id="lasnas" name="lasnas" value="lasnas" checked="true">
    <label for="lasnas"> Restrict las and nas to end-of-shunit</label><br>
    <br>
    <button id="runBtn">Detect quotes</button>

    <div id="heatmapControls" style="margin-top: 0.75rem; font-size: 0.9rem;">
        Heatmap layers:
        <label><input type="checkbox" id="showQuotesHeat" checked> Quotes</label>
        <label><input type="checkbox" id="showAlloHeat" checked> Allo/auto</label>
        <label><input type="checkbox" id="showVerseHeat" checked> Verse</label>
    </div>


    <div id="results" style="margin-top: 1.5rem;"></div>

    <!-- JSZip for reading zip archives in the browser -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <!-- Main logic: text finder + quote detector + allo/allo classifier -->
    <script type="module">
        import { env, pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.4.1';

        // Cache of last run so we can re-render heatmap without recomputing
        let LAST_CLAUSES = null;
        let LAST_LABELS = null;
        let LAST_ALLOAUTO = null;
        let LAST_VERSE = null;


        /********************************************************************
         * GLOBAL CONFIGS
         ********************************************************************/
        const MAX_QUOTE_LENGTH_CHARS = 500;
        const MAX_LEN = 512; // (not currently used, but kept from your original)

        // Configure transformers to use local model only
        env.allowRemoteModels = false;
        env.localModelPath = '.';

        let classifier = null;  // RoBERTa auto/allo classifier (Xenova)
        let classifierReady = false;

        /********************************************************************
         * TEXT FINDER CONFIGURATION
         ********************************************************************/
        const CORPORA = [
            {
                id: "derge",
                label: "Derge",
                zipUrl: "zips/all_derge.zip",
                manifestUrl: "zips/derge_manifest.json"
            },
            {
                id: "nyingma",
                label: "Nyingma",
                zipUrl: "zips/all_nyingma.zip",
                manifestUrl: "zips/nyingma_manifest.json"
            },
            {
                id: "acip",
                label: "ACIP Sungbum",
                zipUrl: "zips/all_sungbum.zip",
                manifestUrl: "zips/sungbum_manifest.json"
            }
        ];

        const ALL_TEXT_ENTRIES = [];
        const ZIP_CACHE = {};

        function setupResultsCopyHandler() {
            const resultsDiv = document.getElementById("results");
            if (!resultsDiv) return;

            resultsDiv.addEventListener("copy", (event) => {
                const selection = window.getSelection();
                if (!selection) return;

                const selectedText = selection.toString();
                if (!selectedText) return;

                // Only intercept if the selection is inside #results
                const anchorNode = selection.anchorNode;
                const focusNode = selection.focusNode;
                const containsAnchor = anchorNode && resultsDiv.contains(anchorNode);
                const containsFocus = focusNode && resultsDiv.contains(focusNode);

                if (!containsAnchor && !containsFocus) {
                    // Let normal copying happen elsewhere (e.g., textarea)
                    return;
                }

                // --- Transform the text ---
                let text = selectedText;

                // Normalize CRLF/CR to LF
                text = text.replace(/\r\n?/g, "\n");

                // Replace all newlines with spaces
                text = text.replace(/\n+/g, " ");

                // Collapse multiple spaces to a single space and trim
                text = text.replace(/\s+/g, " ").trim();

                // Put our cleaned text into the clipboard
                event.preventDefault();
                event.clipboardData.setData("text/plain", text);
            });
        }


        /********************************************************************
         * AUTO/ALLO MODEL LOADING
         ********************************************************************/
        async function loadModel() {
            const modelStatus = document.getElementById("modelStatus");
            try {
                modelStatus.textContent = "Model: loading auto/allo classifier...";
                classifier = await pipeline('text-classification', './model', {
                    quantized: false,
                    revision: 'main',
                    local_files_only: true,
                });
                classifierReady = true;
                modelStatus.textContent = "Model: auto/allo classifier loaded.";
            } catch (e) {
                console.error("Error loading classifier model:", e);
                modelStatus.textContent = "Model: failed to load auto/allo classifier (see console).";
                classifierReady = false;
            }
        }

        /********************************************************************
         * MANIFEST LOADING (TEXT FINDER)
         ********************************************************************/
        async function loadManifests() {
            const statusEl = document.getElementById("textSearchStatus");
            try {
                let idxCounter = 0;
                for (const corpus of CORPORA) {
                    const resp = await fetch(corpus.manifestUrl);
                    if (!resp.ok) {
                        console.warn(`Failed to load manifest for ${corpus.id}:`, resp.status);
                        continue;
                    }
                    const manifest = await resp.json();
                    // Expect: [{ "file": "subdir/D406.txt", "title": "D406 Some Title" }, ...]
                    for (const entry of manifest) {
                        const path = entry.file;
                        const title = entry.title || entry.file;
                        ALL_TEXT_ENTRIES.push({
                            corpusId: corpus.id,
                            corpusLabel: corpus.label,
                            zipUrl: corpus.zipUrl,
                            path: path,
                            displayName: title,
                            index: idxCounter++
                        });
                    }
                }
                if (ALL_TEXT_ENTRIES.length === 0) {
                    statusEl.textContent = "No texts found in manifests (check manifest URLs).";
                } else {
                    statusEl.textContent = `Loaded ${ALL_TEXT_ENTRIES.length} texts. Type to search.`;
                }
            } catch (err) {
                console.error("Error loading manifests:", err);
                statusEl.textContent = "Error loading indexes (see console).";
            }
        }

        /********************************************************************
         * TEXT FINDER SEARCH + RENDER
         ********************************************************************/
        function searchTexts(query, limit = 10) {
            if (!query) return [];
            const q = query.toLowerCase();

            const matches = [];
            for (const entry of ALL_TEXT_ENTRIES) {
                const dname = entry.displayName.toLowerCase();
                const pth = entry.path.toLowerCase();
                const idxName = dname.indexOf(q);
                const idxPath = pth.indexOf(q);
                if (idxName === -1 && idxPath === -1) continue;

                const rawIdx = idxName !== -1 ? idxName : 1000 + idxPath;
                const score = rawIdx + 0.001 * dname.length;
                matches.push({ entry, score });
            }

            matches.sort((a, b) => a.score - b.score);
            return matches.slice(0, limit).map(m => m.entry);
        }

        function renderSearchResults(entries) {
            const resultsEl = document.getElementById("textSearchResults");
            const statusEl = document.getElementById("textSearchStatus");

            if (!entries || entries.length === 0) {
                resultsEl.innerHTML = "<em>No matches.</em>";
                return;
            }

            statusEl.textContent = `Showing top ${entries.length} matches.`;

            let html = "";
            for (const entry of entries) {
                const safeName = escapeHtml(entry.displayName);
                const safePath = escapeHtml(entry.path);
                const safeCorpus = escapeHtml(entry.corpusLabel);

                html += `
<div class="text-finder-item">
  <div>
    <span>${safeName}</span>
    <div class="text-finder-meta">[${safeCorpus}] ${safePath}</div>
  </div>
  <button type="button"
          data-entry-index="${entry.index}">
    Load
  </button>
</div>`;
            }
            resultsEl.innerHTML = html;
        }

        /********************************************************************
         * TEXT FINDER: ZIP LOADING + TEXT EXTRACTION
         ********************************************************************/
        async function getZipForCorpus(corpusId, zipUrl) {
            if (!ZIP_CACHE[corpusId]) {
                const resp = await fetch(zipUrl);
                if (!resp.ok) {
                    throw new Error(`Failed to fetch zip for ${corpusId}: ${resp.status}`);
                }
                const buf = await resp.arrayBuffer();
                ZIP_CACHE[corpusId] = JSZip.loadAsync(buf);
            }
            return ZIP_CACHE[corpusId];
        }

        async function loadTextEntryIntoTextarea(entry) {
            const statusEl = document.getElementById("textSearchStatus");
            try {
                statusEl.textContent = `Loading ${entry.displayName} from ${entry.corpusLabel}...`;

                const zip = await getZipForCorpus(entry.corpusId, entry.zipUrl);
                const file = zip.file(entry.path);
                if (!file) {
                    alert(`Could not find file "${entry.path}" in ${entry.corpusLabel} zip.`);
                    statusEl.textContent = "File not found in zip.";
                    return;
                }

                const text = await file.async("string");
                const textarea = document.getElementById("inputText");
                textarea.value = text;
                statusEl.textContent = `Loaded ${entry.displayName} into the detector.`;
                textarea.focus();
            } catch (err) {
                console.error("Error loading text from zip:", err);
                alert("Failed to load text from zip (see console).");
                statusEl.textContent = "Error loading text.";
            }
        }

        /********************************************************************
         * HELPER FUNCTIONS (SHARED)
         ********************************************************************/
        function escapeHtml(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function softmax(arr) {
            const max = Math.max(...arr);
            const exps = arr.map(x => Math.exp(x - max));
            const sum = exps.reduce((a, b) => a + b, 0);
            return exps.map(x => x / sum);
        }

        function nextFrame() {
            return new Promise(resolve => requestAnimationFrame(resolve));
        }

        // Map auto-probability p (0..1) to redâ†’blue gradient
        function autoProbToColor(pAuto) {
            const p = Math.min(1, Math.max(0, pAuto));
            const r = Math.round(255 * (1 - p));   // 1 -> 0
            const g = 0;
            const b = Math.round(255 * p);         // 0 -> 255
            return `rgb(${r},${g},${b})`;
        }

        /********************************************************************
         * VERSE DETECTION (ported from Python analyze_file)
         ********************************************************************/
        const VERSE_METER_COUNTS = [7, 9, 11];
        const VERSE_MIN_SECTION_LENGTH = 4;
        const VERSE_MIN_PROBABILITY = 0.7;
        const IGNORE_CHARS_REGEX = /[/@#;:()]/g;

        function countSyllables(line) {
            // Remove ignored chars, split on whitespace
            const cleaned = line.replace(IGNORE_CHARS_REGEX, "").trim();
            if (!cleaned) return 0;
            return cleaned.split(/\s+/).length;
        }

        /**
         * Detect verse sections over a list of clauses.
         * Returns an array of booleans: verseFlags[i] = true if clause i is in verse.
         */
        function detectVerseLines(clauses) {
            const n = clauses.length;
            const verseFlags = new Array(n).fill(false);
            const syllableCounts = clauses.map(countSyllables);

            let i = 0;
            while (i < n) {
                const firstCount = syllableCounts[i];
                if (!VERSE_METER_COUNTS.includes(firstCount)) {
                    i += 1;
                    continue;
                }
                const currentMeter = firstCount;

                let currentWeight = 1.0;
                let currentMaxWeight = 1.0;
                let sectionStart = i;
                let sectionEnd = i;
                let nextLine = i + 1;

                // Extend section while probability stays above threshold
                while (
                    nextLine < n &&
                    (currentWeight / currentMaxWeight) >= VERSE_MIN_PROBABILITY
                ) {
                    const c = syllableCounts[nextLine];
                    if (c === currentMeter) {
                        currentWeight += 1.0;
                    } else if (Math.abs(c - currentMeter) === 1) {
                        currentWeight += 0.5;
                    } else {
                        break;
                    }
                    currentMaxWeight += 1.0;
                    sectionEnd = nextLine;
                    nextLine += 1;
                }

                if (sectionEnd - sectionStart + 1 >= VERSE_MIN_SECTION_LENGTH) {
                    for (let k = sectionStart; k <= sectionEnd; k++) {
                        verseFlags[k] = true;
                    }
                }

                i = sectionEnd + 1;
            }

            return verseFlags;
        }

        /********************************************************************
         * AUTO/ALLO CLASSIFICATION PER CLAUSE
         ********************************************************************/
        async function classifyClauses(clauses) {
            const modelStatus = document.getElementById("modelStatus");

            // If classifier isn't ready, just give neutral scores (0.5)
            if (!classifierReady || !classifier) {
                return clauses.map(() => ({ allo: 0.5, auto: 0.5 }));
            }

            const results = [];
            for (let i = 0; i < clauses.length; i++) {
                const clause = clauses[i];
                try {
                    const tokens = await classifier.tokenizer(clause);
                    const output = await classifier.model(tokens);
                    const logits = output.logits.data;
                    const [allo, auto] = softmax(Array.from(logits)); // assume [allo, auto]
                    results.push({ allo, auto });
                } catch (e) {
                    console.error(`Error classifying clause ${i}:`, e);
                    results.push({ allo: 0.5, auto: 0.5 });
                }

                // Occasionally yield to the browser
                if (i % 10 === 0) {
                    modelStatus.textContent =
                        `Model: auto/allo classifier loaded. Classifying ${i + 1}/${clauses.length} clauses...`;
                    await nextFrame();
                }
            }

            modelStatus.textContent =
                `Model: auto/allo classifier loaded. Classified ${clauses.length} clauses.`;
            return results;
        }

        /********************************************************************
         * QUOTE DETECTION LOGIC
         ********************************************************************/
        function getOpenCloseRegexes(lasnas) {
            let potentialOpeners = [
                "las kyang ji skad du",
                "las kyang",
                //"las",
                "ji skad du",
                "las 'byung ba",
                "las ji skad du",
                "de bzhin du",
                "de'i phyir",
                "ji skad smras pa",
                "'dir smras pa",
                "de nyid kyi phyir",
                "mdo las",
                "rgyud las",
                "de nyid las",
                "bstan bcos las",
                "las kyang",
                "de skad du",
                "di skad ces",
                "tshigs su bcad pa",
                "'dir tshigs su bcad pa",
            ];
            if (lasnas === true) {
                potentialOpeners.push("las$");
            } else {
                potentialOpeners.push("las");
            }
            potentialOpeners.sort((a, b) => b.length - a.length);

            let baseClosers = [
                "zhes gsungs so",
                "zhes ji skad gsungs pa lta bu'o",
                "zhes 'byung ngo",
                "zhes gsungs pa'i phyir ro",
                "ces gsungs so",
                "zhes gsungs te",
                "zhes gsungs pa",
                "zhes gsungs pa yin no",
                "zhes gsungs pa lta bu'o",
                "gsungs so",
                "zhes bya ba dang",
                "ces gsungs te",
                "ces gsungs pa'i phyir ro",
                "zhes bya ba gsungs so",
                "zhes bshad do",
                "ces gsungs pa lta bu'o",
                "zhes pa",
                "zhes gsungs pa nyid blta bar bya'o",
                "zhes gsungs pa'o",
                "zhes bshad pa'i phyir ro",
                "ces gsungs pa",
                "zhes bshad pa lta bu'o",
                "ces bya ba gsungs te",
                "zhes gsungs",
                "zhe'o",
                "zhes rgya cher gsungs so",
                "gsungs pa lta bu'o",
                "zhes rgya cher gsungs pa lta bu'o",
                "zhes bshad do",
                "zhes bya ba smos",
                "ji lta ba bzhin du rab tu shes so",
                "ces bya ba smos",
                "ces bstan to",
                "zhes bstan to",
                "zhes pa smra'o",
            ];
            baseClosers.sort((a, b) => b.length - a.length);
            const extraCloserRegex = "zhes(?! bya ba)";

            function escapeRegExp(str) {
                return str.replace(/[.*+?^{}()|[\]\\]/g, '\\$&');
            }

            const openerRegexSrc =
                "(\\b" + potentialOpeners.map(escapeRegExp).join("\\b|\\b") + "\\b)";

            const closerRegexParts = baseClosers.map(escapeRegExp);
            closerRegexParts.push(extraCloserRegex);
            const closerRegexSrc =
                "(\\b" + closerRegexParts.join("\\b|\\b") + "\\b)";

            const openerRegex = new RegExp(openerRegexSrc, "u");
            const closerRegex = new RegExp(closerRegexSrc, "u");

            console.log("Opener regex:", openerRegex);
            console.log("Closer regex:", closerRegex);

            return [openerRegex, closerRegex, openerRegexSrc, closerRegexSrc];
        }

        function splitClauses(text) {
            // Keep this: normalize CRLF / CR to a space (some input needs this).
            const normalized = text.replace(/\r\n?/g, " ");

            // Replace any group of one or more slashes, possibly separated by spaces,
            // with the same group plus a newline.
            //
            // Examples:
            //   " / "        -> " / \n"
            //   " / / //  "  -> " / / // \n"
            //
            const withNewlines = normalized.replace(/((?:\s*\/)+)\s*/gu, "$1\n");

            // Now split on the newlines we just introduced.
            // We trim spaces but *do not* remove the tshads themselves.
            return withNewlines
                .split("\n")
                .map(c => c.trim())
                .filter(c => c.length > 0);
        }

        function detectQuotes(clauses) {
            const las_nas_shunit = document.getElementById("lasnas").checked;
            console.log("las_nas_shunit =", las_nas_shunit);

            const [openerRegex, closerRegex] = getOpenCloseRegexes(las_nas_shunit);

            const labels = new Array(clauses.length).fill("none");
            let i = 0;

            while (i < clauses.length) {
                const clause = clauses[i];
                const openerMatch = openerRegex.exec(clause);
                openerRegex.lastIndex = 0;

                if (openerMatch) {
                    for (let j = i + 1; j < clauses.length; j++) {
                        const closerMatch = closerRegex.exec(clauses[j]);
                        closerRegex.lastIndex = 0;

                        if (closerMatch) {
                            const openerText = openerMatch[0];
                            const closerText = closerMatch[0];

                            if ((openerText === "las" || openerText === "nas") && closerText === "zhes") {
                                continue;
                            }

                            const quoteContent = clauses.slice(i + 1, j).join(" ");
                            if (quoteContent.length <= MAX_QUOTE_LENGTH_CHARS) {
                                labels[i] = "opener";
                                for (let k = i + 1; k < j; k++) {
                                    labels[k] = "inquote";
                                }
                                labels[j] = "closer";
                                i = j;
                            }
                            break;
                        }
                    }
                }

                i += 1;
            }

            return labels;
        }

        function renderResults(clauses, labels, alloAutoScores, verseFlags) {
        const las_nas_shunit = document.getElementById("lasnas").checked;
            console.log("las_nas_shunit =", las_nas_shunit);

            const [, , openerRegexSrc, closerRegexSrc] = getOpenCloseRegexes(las_nas_shunit);

            // Read heatmap toggles
            const showQuotes = document.getElementById("showQuotesHeat")?.checked ?? true;
            const showAllo   = document.getElementById("showAlloHeat")?.checked ?? true;
            const showVerse  = document.getElementById("showVerseHeat")?.checked ?? true;
            const neutralColor = "#f5f5f5";

            const quoteColorMap = {
                opener: "#d0f0fd",
                inquote: "#fef7cb",
                closer: "#ffd0d0",
                none: "#ffffff"
            };

            let html = "";
            html += "<h2>Heatmap</h2>";
            html += "<div class='heatmap'>";

            for (let i = 0; i < labels.length; i++) {
                const lbl = labels[i];
                const idxStr = i.toString().padStart(4, "0");
                const score = alloAutoScores && alloAutoScores[i] ? alloAutoScores[i] : { allo: 0.5, auto: 0.5 };
                const pAuto = score.auto;
                const verse = verseFlags && verseFlags[i];

                const quoteColor = showQuotes ? (quoteColorMap[lbl] || "#ffffff") : neutralColor;
                const alloColor  = showAllo   ? autoProbToColor(pAuto)             : neutralColor;
                const verseColor = showVerse  ? (verse ? "#4caf50" : "#dddddd")    : neutralColor;

                const title = `Line ${idxStr}
Quote: ${lbl}
Allo: ${score.allo.toFixed(2)}, Auto: ${score.auto.toFixed(2)}
Verse: ${verse ? "yes" : "no"}`;

                html += `
<a href="#line-${idxStr}" title="${escapeHtml(title)}">
<div class="heatbox">
    <div class="heatband" style="background:${quoteColor};"></div>
    <div class="heatband" style="background:${alloColor};"></div>
    <div class="heatband" style="background:${verseColor};"></div>
</div>
</a>`;
            }

            html += "</div><hr>";

            for (let i = 0; i < clauses.length; i++) {
                const clause = clauses[i];
                const label = labels[i];
                const idxStr = i.toString().padStart(4, "0");
                const clauseEsc = escapeHtml(clause);

                // --- auto/allo badge ---
                const score = alloAutoScores && alloAutoScores[i] ? alloAutoScores[i] : { allo: 0.5, auto: 0.5 };
                const pAuto = score.auto;
                const color = autoProbToColor(pAuto);
                const badgeText = pAuto.toFixed(2);
                const titleText = `Allo: ${score.allo.toFixed(2)}, Auto: ${score.auto.toFixed(2)}`;
                const badgeHtml =
                    `<span class="allo-auto-badge" style="background-color:${color};" title="${escapeHtml(titleText)}">${badgeText}</span>`;

                let highlighted = clauseEsc;

                if (label === "opener") {
                    const localOpenerRe = new RegExp(openerRegexSrc, "u");
                    const m = localOpenerRe.exec(clause);
                    if (m) {
                        const start = m.index;
                        const end = start + m[0].length;
                        highlighted =
                            escapeHtml(clause.slice(0, start)) +
                            `<span class="opener">${escapeHtml(clause.slice(start, end))}</span>` +
                            `<span class="inquote">` +
                            escapeHtml(clause.slice(end)) +
                            `</span>`;
                    }
                } else if (label === "closer") {
                    const localCloserRe = new RegExp(closerRegexSrc, "u");
                    const m = localCloserRe.exec(clause);
                    if (m) {
                        const start = m.index;
                        const end = start + m[0].length;
                        highlighted =
                            `<span class="inquote">` +
                            escapeHtml(clause.slice(0, start)) +
                            `</span>` +
                            `<span class="closer">${escapeHtml(clause.slice(start, end))}</span>` +
                            escapeHtml(clause.slice(end));
                    }
                } else if (label === "inquote") {
                    highlighted = `<span class="inquote">${clauseEsc}</span>`;
                }

                // Bold verse lines
                let finalText = highlighted;
                if (verseFlags && verseFlags[i]) {
                    finalText = `<span class="verse-line">${highlighted}</span>`;
                }

                // html += `<div id="line-${idxStr}" class="clause-line">${badgeHtml}<strong>${idxStr}:</strong> ${finalText}</div>`;
                html += `
  <div id="line-${idxStr}" class="clause-line">
    <span class="meta-unselectable">
      ${badgeHtml}<strong>${idxStr}:</strong>&nbsp;
    </span>
    ${finalText}
  </div>`;

            }

            return html;
        }

        /********************************************************************
         * WIRE UP UI
         ********************************************************************/
        // Quote detector button (now async because of classifier)
        document.getElementById("runBtn").addEventListener("click", async () => {
            const input = document.getElementById("inputText").value || "";
            const resultsDiv = document.getElementById("results");

            const clauses = splitClauses(input);
            if (clauses.length === 0) {
                resultsDiv.innerHTML = "<p><em>No clauses found. Did you paste any text?</em></p>";
                return;
            }

            const verseFlags = detectVerseLines(clauses);
            const alloAutoScores = await classifyClauses(clauses);
            const labels = detectQuotes(clauses);

            // cache
            LAST_CLAUSES = clauses;
            LAST_LABELS = labels;
            LAST_ALLOAUTO = alloAutoScores;
            LAST_VERSE = verseFlags;

            const html = renderResults(clauses, labels, alloAutoScores, verseFlags);
            resultsDiv.innerHTML = html;
        });

        // Text search input
        document.getElementById("textSearchInput").addEventListener("input", (e) => {
            const q = e.target.value.trim();
            if (!q) {
                document.getElementById("textSearchResults").innerHTML = "";
                document.getElementById("textSearchStatus").textContent = "Type to search.";
                return;
            }
            const matches = searchTexts(q, 10);
            renderSearchResults(matches);
        });

        // Delegate click for "Load" buttons in search results
        document.getElementById("textSearchResults").addEventListener("click", (e) => {
            const btn = e.target.closest("button[data-entry-index]");
            if (!btn) return;
            const idx = parseInt(btn.getAttribute("data-entry-index"), 10);
            const entry = ALL_TEXT_ENTRIES.find(ent => ent.index === idx);
            if (!entry) {
                alert("Could not find selected entry (internal error).");
                return;
            }
            loadTextEntryIntoTextarea(entry);
        });

        // Kick off manifest + model loading after page is ready
        window.addEventListener("load", () => {
            loadManifests();
            loadModel();
            setupResultsCopyHandler();
        });
    
        function rerenderWithCurrentHeatmap() {
            if (!LAST_CLAUSES) return;
            const resultsDiv = document.getElementById("results");
            const html = renderResults(LAST_CLAUSES, LAST_LABELS, LAST_ALLOAUTO, LAST_VERSE);
            resultsDiv.innerHTML = html;
        }

        ["showQuotesHeat", "showAlloHeat", "showVerseHeat"].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener("change", rerenderWithCurrentHeatmap);
            }
        });

    </script>

</body>

</html>