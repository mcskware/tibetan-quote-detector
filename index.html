<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Classical Tibetan Quote Detection</title>
    <style>
        body {
            font-family: monospace;
            margin: 1rem;
        }

        h1 {
            margin-top: 0;
        }

        textarea {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            font-family: monospace;
        }

        button {
            margin-top: 0.5rem;
            padding: 0.4rem 0.8rem;
            font-family: inherit;
            cursor: pointer;
        }

        .heatmap {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 1em;
        }

        .heatbox {
            width: 10px;
            height: 10px;
            margin: 1px;
            border: 1px solid #ccc;
        }

        .opener {
            background-color: #d0f0fd;
        }

        .inquote {
            background-color: #fef7cb;
        }

        .closer {
            background-color: #ffd0d0;
        }

        .none {
            background-color: white;
        }

        span.opener,
        span.inquote,
        span.closer {
            padding: 0 2px;
            border-radius: 3px;
        }

        .clause-line {
            margin-bottom: 0.1rem;
        }

        /* Text finder styles */
        .text-finder {
            border: 1px solid #ccc;
            padding: 0.5rem;
            margin-bottom: 1rem;
        }

        .text-finder input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            font-family: monospace;
            padding: 0.25rem;
        }

        .text-finder-results {
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid #eee;
            padding-top: 0.5rem;
        }

        .text-finder-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px dashed #eee;
            font-size: 0.9rem;
        }

        .text-finder-item span {
            margin-right: 0.5rem;
        }

        .text-finder-meta {
            color: #555;
            font-size: 0.8rem;
        }
    </style>
</head>

<body>
    <h1>Classical Tibetan Quote Detection</h1>

    <!-- TEXT FINDER UI -->
    <div class="text-finder">
        <strong>Find a text from Derge / Nyingma / ACIP Sungbum</strong>
        <p style="margin-top:0.25rem;">
            Start typing part of the text name or filename (e.g. <code>D406</code>), then click a match to load it into
            the detector.
        </p>
        <input type="text" id="textSearchInput" placeholder="Type part of a text name or filename...">
        <div id="textSearchStatus" style="margin-top:0.25rem; font-size:0.8rem; color:#555;">
            Loading corpus indexes...
        </div>
        <div id="textSearchResults" class="text-finder-results"></div>
    </div>

    <p>
        Paste your Tibetan text below (clauses separated by <code>/</code> or <code>//</code>),
        then click <strong>Detect quotes</strong>.
    </p>

    <textarea id="inputText" rows="10" placeholder="Paste Tibetan text here..."></textarea>
    <br>
    <input type="checkbox" id="lasnas" name="lasnas" value="lasnas" checked="true">
    <label for="lasnas"> Restrict las and nas to end-of-shunit</label><br>
    <br>
    <button id="runBtn">Detect quotes</button>

    <div id="results" style="margin-top: 1.5rem;"></div>

    <!-- JSZip for reading zip archives in the browser -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script>
        /********************************************************************
         * CONFIGURATION FOR TEXT FINDER
         ********************************************************************/

        // Adjust these URLs to wherever you host your zip and manifest files.
        // The manifest files should be small JSONs listing the texts inside each zip.
        const CORPORA = [
            {
                id: "derge",
                label: "Derge",
                zipUrl: "zips/all_derge.zip",
                manifestUrl: "zips/derge_manifest.json"
            },
            {
                id: "nyingma",
                label: "Nyingma",
                zipUrl: "zips/all_nyingma.zip",
                manifestUrl: "zips/nyingma_manifest.json"
            },
            {
                id: "acip",
                label: "ACIP Sungbum",
                zipUrl: "zips/all_sungbum.zip",
                manifestUrl: "zips/sungbum_manifest.json"
            }
        ];

        // Will hold all entries from all corpora:
        // {
        //   corpusId, corpusLabel, zipUrl,
        //   path,        // path inside zip, e.g. "D406.txt"
        //   displayName, // human-readable label; may just be the filename
        //   index        // stable numeric ID for this entry
        // }
        const ALL_TEXT_ENTRIES = [];

        // Cache of JSZip instances, one per corpusId.
        const ZIP_CACHE = {};

        /********************************************************************
         * TEXT FINDER: MANIFEST LOADING
         ********************************************************************/

        async function loadManifests() {
            const statusEl = document.getElementById("textSearchStatus");
            try {
                let idxCounter = 0;
                for (const corpus of CORPORA) {
                    const resp = await fetch(corpus.manifestUrl);
                    if (!resp.ok) {
                        console.warn(`Failed to load manifest for ${corpus.id}:`, resp.status);
                        continue;
                    }
                    const manifest = await resp.json();
                    // Expect manifest to be an array of objects like:
                    // { "file": "D406.txt", "title": "D406 Some Text Name" }
                    for (const entry of manifest) {
                        const path = entry.file;
                        const title = entry.title || entry.file;
                        ALL_TEXT_ENTRIES.push({
                            corpusId: corpus.id,
                            corpusLabel: corpus.label,
                            zipUrl: corpus.zipUrl,
                            path: path,
                            displayName: title,
                            index: idxCounter++
                        });
                    }
                }

                if (ALL_TEXT_ENTRIES.length === 0) {
                    statusEl.textContent = "No texts found in manifests (check manifest URLs).";
                } else {
                    statusEl.textContent = `Loaded ${ALL_TEXT_ENTRIES.length} texts. Type to search.`;
                }
            } catch (err) {
                console.error("Error loading manifests:", err);
                statusEl.textContent = "Error loading indexes (see console).";
            }
        }

        /********************************************************************
         * TEXT FINDER: SEARCH + RENDER
         ********************************************************************/

        function searchTexts(query, limit = 10) {
            if (!query) return [];
            const q = query.toLowerCase();

            // Simple substring search over displayName and path
            const matches = [];
            for (const entry of ALL_TEXT_ENTRIES) {
                const dname = entry.displayName.toLowerCase();
                const pth = entry.path.toLowerCase();
                const idxName = dname.indexOf(q);
                const idxPath = pth.indexOf(q);
                if (idxName === -1 && idxPath === -1) continue;

                // Score: prefer matches earlier in the string, prefer shorter names
                const rawIdx = idxName !== -1 ? idxName : 1000 + idxPath;
                const score = rawIdx + 0.001 * dname.length;
                matches.push({ entry, score });
            }

            matches.sort((a, b) => a.score - b.score);
            return matches.slice(0, limit).map(m => m.entry);
        }

        function renderSearchResults(entries) {
            const resultsEl = document.getElementById("textSearchResults");
            const statusEl = document.getElementById("textSearchStatus");

            if (!entries || entries.length === 0) {
                resultsEl.innerHTML = "<em>No matches.</em>";
                return;
            }

            statusEl.textContent = `Showing top ${entries.length} matches.`;

            let html = "";
            for (const entry of entries) {
                const safeName = escapeHtml(entry.displayName);
                const safePath = escapeHtml(entry.path);
                const safeCorpus = escapeHtml(entry.corpusLabel);

                html += `
<div class="text-finder-item">
  <div>
    <span>${safeName}</span>
    <div class="text-finder-meta">[${safeCorpus}] ${safePath}</div>
  </div>
  <button type="button"
          data-entry-index="${entry.index}">
    Load
  </button>
</div>`;
            }

            resultsEl.innerHTML = html;
        }

        /********************************************************************
         * TEXT FINDER: ZIP LOADING + TEXT EXTRACTION
         ********************************************************************/

        async function getZipForCorpus(corpusId, zipUrl) {
            if (!ZIP_CACHE[corpusId]) {
                // First time: fetch and load the zip
                const resp = await fetch(zipUrl);
                if (!resp.ok) {
                    throw new Error(`Failed to fetch zip for ${corpusId}: ${resp.status}`);
                }
                const buf = await resp.arrayBuffer();
                ZIP_CACHE[corpusId] = JSZip.loadAsync(buf);
            }
            return ZIP_CACHE[corpusId];
        }

        async function loadTextEntryIntoTextarea(entry) {
            const statusEl = document.getElementById("textSearchStatus");
            try {
                statusEl.textContent = `Loading ${entry.displayName} from ${entry.corpusLabel}...`;

                const zip = await getZipForCorpus(entry.corpusId, entry.zipUrl);
                const file = zip.file(entry.path);
                if (!file) {
                    alert(`Could not find file "${entry.path}" in ${entry.corpusLabel} zip.`);
                    statusEl.textContent = "File not found in zip.";
                    return;
                }

                const text = await file.async("string");
                const textarea = document.getElementById("inputText");
                textarea.value = text;
                statusEl.textContent = `Loaded ${entry.displayName} into the detector.`;
                textarea.focus();
            } catch (err) {
                console.error("Error loading text from zip:", err);
                alert("Failed to load text from zip (see console).");
                statusEl.textContent = "Error loading text.";
            }
        }

        /********************************************************************
         * EXISTING QUOTE DETECTOR CODE (UNCHANGED)
         ********************************************************************/

        const MAX_QUOTE_LENGTH_CHARS = 500;

        function getOpenCloseRegexes(lasnas) {

            let potentialOpeners = [
                "las kyang ji skad du",
                "las kyang",
                //"las",
                "ji skad du",
                "las 'byung ba",
                "las ji skad du",
                "de bzhin du",
                "de'i phyir",
                "ji skad smras pa",
                "'dir smras pa",
                "de nyid kyi phyir",
                "mdo las",
                "rgyud las",
                "de nyid las",
                "bstan bcos las",
                "las kyang",
                "de skad du",
                "di skad ces",
                "tshigs su bcad pa",
                "'dir tshigs su bcad pa",
            ];
            if (lasnas == true) {
                potentialOpeners.push("las$");
            } else {
                potentialOpeners.push("las");
            }
            potentialOpeners.sort((a, b) => b.length - a.length);

            let baseClosers = [
                "zhes gsungs so",
                "zhes ji skad gsungs pa lta bu'o",
                "zhes 'byung ngo",
                "zhes gsungs pa'i phyir ro",
                "ces gsungs so",
                "zhes gsungs te",
                "zhes gsungs pa",
                "zhes gsungs pa yin no",
                "zhes gsungs pa lta bu'o",
                "gsungs so",
                "zhes bya ba dang",
                "ces gsungs te",
                "ces gsungs pa'i phyir ro",
                "zhes bya ba gsungs so",
                "zhes bshad do",
                "ces gsungs pa lta bu'o",
                "zhes pa",
                "zhes gsungs pa nyid blta bar bya'o",
                "zhes gsungs pa'o",
                "zhes bshad pa'i phyir ro",
                "ces gsungs pa",
                "zhes bshad pa lta bu'o",
                "ces bya ba gsungs te",
                "zhes gsungs",
                "zhe'o",
                "zhes rgya cher gsungs so",
                "gsungs pa lta bu'o",
                "zhes rgya cher gsungs pa lta bu'o",
                "zhes bshad do",
                "zhes bya ba smos",
                "ji lta ba bzhin du rab tu shes so",
                "ces bya ba smos",
                "ces bstan to",
                "zhes bstan to",
                "zhes pa smra'o",
            ];
            baseClosers.sort((a, b) => b.length - a.length);
            const extraCloserRegex = "zhes(?! bya ba)";

            function escapeRegExp(str) {
                return str.replace(/[.*+?^{}()|[\]\\]/g, '\\$&');
            }

            const openerRegexSrc =
                "(\\b" + potentialOpeners.map(escapeRegExp).join("\\b|\\b") + "\\b)";

            const closerRegexParts = baseClosers.map(escapeRegExp);
            closerRegexParts.push(extraCloserRegex);
            const closerRegexSrc =
                "(\\b" + closerRegexParts.join("\\b|\\b") + "\\b)";

            const openerRegex = new RegExp(openerRegexSrc, "u");
            const closerRegex = new RegExp(closerRegexSrc, "u");

            console.log("Opener regex:", openerRegex);
            console.log("Closer regex:", closerRegex);

            return [openerRegex, closerRegex, openerRegexSrc, closerRegexSrc];
        }

        function escapeHtml(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function splitClauses(text) {
            const normalized = text.replace(/\r\n?/g, " ").replace(/\n/g, " ");
            return normalized
                .split(/\s*\/{1,2}\s*/u)
                .map(c => c.trim())
                .filter(c => c.length > 0);
        }

        function detectQuotes(clauses) {
            var las_nas_shunit = document.getElementById("lasnas").checked;
            console.log("las_nas_shunit =", las_nas_shunit);

            const [openerRegex, closerRegex, openerRegexSrc, closerRegexSrc] = getOpenCloseRegexes(las_nas_shunit);

            const labels = new Array(clauses.length).fill("none");
            let i = 0;

            while (i < clauses.length) {
                const clause = clauses[i];
                const openerMatch = openerRegex.exec(clause);
                openerRegex.lastIndex = 0;

                if (openerMatch) {
                    for (let j = i + 1; j < clauses.length; j++) {
                        const closerMatch = closerRegex.exec(clauses[j]);
                        closerRegex.lastIndex = 0;

                        if (closerMatch) {
                            const openerText = openerMatch[0];
                            const closerText = closerMatch[0];

                            if ((openerText === "las" || openerText === "nas") && closerText === "zhes") {
                                continue;
                            }

                            const quoteContent = clauses.slice(i + 1, j).join(" ");
                            if (quoteContent.length <= MAX_QUOTE_LENGTH_CHARS) {
                                labels[i] = "opener";
                                for (let k = i + 1; k < j; k++) {
                                    labels[k] = "inquote";
                                }
                                labels[j] = "closer";
                                i = j;
                            }
                            break;
                        }
                    }
                }

                i += 1;
            }

            return labels;
        }

        function renderResults(clauses, labels) {
            var las_nas_shunit = document.getElementById("lasnas").checked;
            console.log("las_nas_shunit =", las_nas_shunit);

            const [openerRegex, closerRegex, openerRegexSrc, closerRegexSrc] = getOpenCloseRegexes(las_nas_shunit);

            const colorMap = {
                opener: "#d0f0fd",
                inquote: "#fef7cb",
                closer: "#ffd0d0",
                none: "white"
            };

            let html = "";

            html += "<h2>Quote Detection Heatmap</h2>";
            html += "<div class='heatmap'>";

            for (let i = 0; i < labels.length; i++) {
                const lbl = labels[i];
                const idxStr = i.toString().padStart(4, "0");
                html += `<a href="#line-${idxStr}"><div class="heatbox ${lbl}"></div></a>`;
            }

            html += "</div><hr>";

            for (let i = 0; i < clauses.length; i++) {
                const clause = clauses[i];
                const label = labels[i];
                const idxStr = i.toString().padStart(4, "0");
                const clauseEsc = escapeHtml(clause);

                let highlighted = clauseEsc;

                if (label === "opener") {
                    const localOpenerRe = new RegExp(openerRegexSrc, "u");
                    const m = localOpenerRe.exec(clause);
                    if (m) {
                        const start = m.index;
                        const end = start + m[0].length;
                        highlighted =
                            escapeHtml(clause.slice(0, start)) +
                            `<span class="opener">${escapeHtml(clause.slice(start, end))}</span>` +
                            `<span class="inquote">` +
                            escapeHtml(clause.slice(end)) +
                            `</span>`;
                    }
                } else if (label === "closer") {
                    const localCloserRe = new RegExp(closerRegexSrc, "u");
                    const m = localCloserRe.exec(clause);
                    if (m) {
                        const start = m.index;
                        const end = start + m[0].length;
                        highlighted =
                            `<span class="inquote">` +
                            escapeHtml(clause.slice(0, start)) +
                            `</span>` +
                            `<span class="closer">${escapeHtml(clause.slice(start, end))}</span>` +
                            escapeHtml(clause.slice(end));
                    }
                } else if (label === "inquote") {
                    highlighted = `<span class="inquote">${clauseEsc}</span>`;
                }

                html += `<div id="line-${idxStr}" class="clause-line"><strong>${idxStr}:</strong> ${highlighted}</div>`;
            }

            return html;
        }

        /********************************************************************
         * WIRE UP UI
         ********************************************************************/

        // Quote detector button
        document.getElementById("runBtn").addEventListener("click", () => {
            const input = document.getElementById("inputText").value || "";
            const resultsDiv = document.getElementById("results");

            const clauses = splitClauses(input);
            if (clauses.length === 0) {
                resultsDiv.innerHTML = "<p><em>No clauses found. Did you paste any text?</em></p>";
                return;
            }

            const labels = detectQuotes(clauses);
            const html = renderResults(clauses, labels);
            resultsDiv.innerHTML = html;
        });

        // Text search input
        document.getElementById("textSearchInput").addEventListener("input", (e) => {
            const q = e.target.value.trim();
            if (!q) {
                document.getElementById("textSearchResults").innerHTML = "";
                document.getElementById("textSearchStatus").textContent = "Type to search.";
                return;
            }
            const matches = searchTexts(q, 10);
            renderSearchResults(matches);
        });

        // Delegate click for "Load" buttons in search results
        document.getElementById("textSearchResults").addEventListener("click", (e) => {
            const btn = e.target.closest("button[data-entry-index]");
            if (!btn) return;
            const idx = parseInt(btn.getAttribute("data-entry-index"), 10);
            const entry = ALL_TEXT_ENTRIES.find(e => e.index === idx);
            if (!entry) {
                alert("Could not find selected entry (internal error).");
                return;
            }
            loadTextEntryIntoTextarea(entry);
        });

        // Kick off manifest loading after page is ready
        window.addEventListener("load", () => {
            loadManifests();
        });
    </script>
</body>

</html>